<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

    <style>
        *{
            padding:0;
            margin:0;
            box-sizing: border-box;
        }

        body{
            /* super responsive */
            display:flex;
            justify-content: center;
        }

        .root{
            position:relative !important;
            width:600px;
            height:600px;
            border:1px solid red;
            /* display:flex; */
            /* flex-wrap: wrap; */
        }

        .cell{
            left:0;
            top:0;
            position:absolute !important;
            /* width:100px; */
            /* height:100px; */
            background:black;
            border-radius: 50%;;
        }

        .radar{
            left:0;
            top:0;
            position:absolute !important;
            width:1px;
            height:1px;
            /* position: relative; */
            background:blue;
        }

    </style>
</head>
<body>

    <div class="root"></div>
    
</body>

<script id="config">
    const CONFIG = {
        "field_width":600,
        "field_height":600,
        "px_move":1.5,
        "game_tick":1000/60,
        "change_spell_surrounded_true":5,
        "change_spell_surrounded_false":3,
        "change_type_spelled_time":5,
        "time_ever rightPosition = protoCell.x - protoCell.size;y_n_ms":20000
    };
</script>

<script>
    
    // INIT 
    const root = document.querySelector(".root");
    root.style.width = CONFIG.field_width;
    root.style.height = CONFIG.field_height;

    const cells = [];
    const radarDistance = 50;

    // CELLS CREATION
    for (let i = 0; i <= 60; i++) {
        //const percentageX = Math.floor(Math.random()*100);
        //const percentageY = Math.floor(Math.random()*100);
        // min size = 4;
        const percentageS = 4 + Math.floor(Math.random()*40);
        const protoCell = {
            id : Math.random(),
            x:Math.floor(Math.random()*CONFIG.field_width),
            y:Math.floor(Math.random()*CONFIG.field_height),
            size:percentageS,
            type:Math.random()*10 < 5.000,
            getCenter:function(){return {x:this.x + this.size/2 ,y:this.y + this.size/2}},
            near:[]
        }
        printHtmlCell(protoCell);
        //emitRadar(radarDistance, protoCell);
        //radar(radarDistance , protoCell.getCenter(), protoCell.size);
        cells.push(protoCell);
        //emitRadar(radarDistance,protoCell);
    }

    // radar for all cells
    cells.forEach(cell => emitRadar(radarDistance,cell));

    // print all near cells of all cells..
    //cells.forEach(cell => console.log(cell.near));
    
    // PRINTS cell in HTML 
    function printHtmlCell(protoCell){
        const exampleCell = document.createElement("span");
        exampleCell.classList.add("cell");
        exampleCell.setAttribute("id", protoCell.id);
        // guarding for right
        if(protoCell.x + protoCell.size > CONFIG.field_width){
            exampleCell.style.left = "20px";
            protoCell.x = 20;
        }else{
            exampleCell.style.left = protoCell.x + "px";
        }
        // guarding for bottom
        if(protoCell.y + protoCell.size > CONFIG.field_height){
            exampleCell.style.top = "20px";
            protoCell.y = 20;
        }else{
            exampleCell.style.top = protoCell.y + "px";
        }

        // background color
        if(protoCell.type){
            exampleCell.style.backgroundColor = "green";
        }
        
        exampleCell.style.width = protoCell.size + "px";
        exampleCell.style.height = protoCell.size + "px";
        root.appendChild(exampleCell);
    }

    // MOVE CELLS
    function moveCell(cell){

        const x_y_randomDirection = () => {
           return Math.random()*10 < 5.000 ? CONFIG.px_move : -CONFIG.px_move;
        }

        let directionX = x_y_randomDirection();
        let directionY = x_y_randomDirection();

        // when radar detects near cells
        if(cell.near.length > 0){
            let averagePositionX = 0;
            let averagePositionY = 0;
            const nearFalse = cell.near.filter(near=>!near.type); 
            const nearTrue = cell.near.filter(near=>near.type);

            // check if cell is true
            if(cell.type === true){
                if(nearFalse.length > 0){   
                    //priority true: move away from false
                    const directions = getAwayFrom(nearFalse , cell);
                    // get other direction
                    directionX = directions.directionX;
                    directionY = directions.directionY
                } // if radar true has no false, go random

            }else{ //cell.type === false
                if(nearTrue.length > 0){

                }else{
                // if radar false has no true, search for false
                    const directions = getTowardsTo(nearFalse , cell);
                    // get other direction
                    directionX = directions.directionX;
                    directionY = directions.directionY;
                }
            }

        }

        // guarding for right, and left
        if( directionX + (cell.x + cell.size) > CONFIG.field_width ){
            cell.x += -directionX;
        }else if(directionX + cell.x < 0){
            cell.x += -directionX;
        }else{
            cell.x += directionX;
        }

        // guarding bottom, and top
        if( directionY + (cell.y + cell.size) > CONFIG.field_height){
            cell.y += -directionY;
        }else if(directionY + cell.y < 0){
            cell.y += -directionY;
        }
        else{
            cell.y += directionY;
        }

    }

    function getAwayFrom(detectedNear , cell){
        let accumulatorX = 0, accumulatorY = 0;

        detectedNear.forEach(nf => {
            accumulatorX += nf.x;
            accumulatorY += nf.y;
        
        });
        averagePositionX = accumulatorX / detectedNear.length ;
        averagePositionY = accumulatorY / detectedNear.length ;
        // get other direction
        directionX = averagePositionX < cell.x ? CONFIG.px_move : -CONFIG.px_move 
        // get other direction
        directionY = averagePositionY < cell.y ? CONFIG.px_move : -CONFIG.px_move 

        return{directionX,directionY}
    }

    function getTowardsTo(detectedNear , cell){
        let accumulatorX = 0, accumulatorY = 0;

        detectedNear.forEach(nf => {
            accumulatorX += nf.getCenter().x;
            accumulatorY += nf.getCenter().y;
        });
        averagePositionX = accumulatorX / detectedNear.length ;
        averagePositionY = accumulatorY / detectedNear.length ;

        console.log(averagePositionX);

        // const span = document.createElement("span");
        // span.style.position = "absolute";
        // span.style.width = "3px";
        // span.style.height = "3px";
        // span.style.top = averagePositionY + "px";
        // span.style.left = averagePositionX+  "px";
        // span.style.backgroundColor = "red";
        // root.appendChild(span);



        // get other direction
        directionX = cell.getCenter().x < averagePositionX ? CONFIG.px_move : -CONFIG.px_move
        // get other direction
        directionY = cell.getCenter().y < averagePositionY ? CONFIG.px_move : -CONFIG.px_move

        return{directionX,directionY}
    }

    function moveHtmlCell(cell){
        cell_ = document.getElementById(cell.id);
        cell_.style.left = cell.x+"px";
        cell_.style.top = cell.y+"px";
    }

    //

    //

    //

    //

    // GAME LOOP

    setInterval(()=>{
        cells.forEach(cell=>{
            // empty near before radar
            cell.near = [];
            // spread radar
            emitRadar(radarDistance,cell);
            //give new coordinates
            moveCell(cell);
            // translate
            moveHtmlCell(cell);

        });
    }, (1000 / 60) );

    //

    //

    //

    //




    // updates the array cell.near[]
    function emitRadar(radarDistance, cell){
        const cellsFound = []
        // every 3 pixel a radar wave
        for(let distance=0; distance<= radarDistance; distance += 4){
            // one radar "turn around"
            const foundCells = radar(distance, cell);
            //add to array cells found from this cell
            foundCells.forEach(cell =>{
                if(!cellsFound.includes(cell)) cellsFound.push(cell);
            });
        }
        cell.near.push(...cellsFound);
    }

    // searches point per point in skew square around the cell for other cells
    function radar(radarDistance, cell){
        // create variables
        const cellSize = cell.size;
        const cellCenter = cell.getCenter();

        // directions
        const points = [[1,1],[1,-1],[-1,-1],[-1,1]];
        let pointsCounter = 0;

        // number radar particles increasing 
        let counterRadarDistance = 0;

        // cells found
        const cellsFound = [];
        
        // starting from top
        const startingPoints = [ 
                [-radarDistance, 0],
                [0, +radarDistance],
                [+radarDistance,0],
                [0, -radarDistance]
            ];
        // or the radar ends to add points before the end..
        const _noIdeaWhy_ = 5;

        // 4 times.. one per side f radar drop
        for (i = 0; i <= radarDistance * points.length + _noIdeaWhy_; i++){
            if(counterRadarDistance > radarDistance){
                // change direction!!
                counterRadarDistance = 0;
                pointsCounter++;
            }else{
                // get another radar point
                counterRadarDistance++;
            }
            // define radar position
            // print first starting top..

            const top = (cellCenter.y + startingPoints[pointsCounter][0]) + 
                        (points[pointsCounter][0] * counterRadarDistance) ;
            const left = (cellCenter.x + startingPoints[pointsCounter][1]) + 
                        (points[pointsCounter][1] * counterRadarDistance) ;

            // const radar = document.createElement("span");
            // // radar.classList.add("radar");

            // array of cells found with this point
            const pointFoundCells = collisionDetection(left,top,cell);

            if(pointFoundCells.length > 0){ 
                //i+=5;
                // add cells to the found array
                pointFoundCells.forEach(cell =>{
                    if(!cellsFound.includes(cell)) cellsFound.push(cell);
                });

                // //radar visualization.. yes is only a wave, but we sww also that..
                //const radar = document.createElement("span");
                //radar.classList.add("radar");
                // radar.style.backgroundColor = "red";
                // radar.style.left =  left + "px";
                // radar.style.top =  top + "px";
                //append to.. HTML ELEMENT!!!
                // root.appendChild(radar);
            }else{
                 //radar.style.backgroundColor = "green";
            }
            // //radar visualization.. yes is only a wave, but we sww also that..
            // radar.style.left =  left + "px";
            // radar.style.top =  top + "px";
            // append to.. HTML ELEMENT!!!
            // root.appendChild(radar);
        }
        // .... radar found cells [] around this cell ...
        
        return cellsFound;
    }


    // returns array of cells different from thisCell found in the point x , y
    function collisionDetection(x,y,thisCell){
        let x_ = false;
        let y_ = false;

        let cellsFoundByPoint = [];

        cells.forEach(cell =>{
            if(cell.id != thisCell.id){
                cell.x < x && cell.x + cell.size > x ? x_=true : x_ = false;
                cell.y < y && cell.y + cell.size > y ? y_=true : y_ = false;
                if( x_ && y_ ) cellsFoundByPoint.push(cell);
            }
        });
        return cellsFoundByPoint;
    }
    


</script>



</html>